<!DOCTYPE html>
<html lang="ru">
@@include('html/_head.htm',{
"title":"Главная"
})

<body>
	<div class="wrapper">
		@@include('html/_header.htm',{})

		<section class="home">

			<div id="home1">
				<h1>Для чего нужны Чертоги Фрилансера v3? Презентация шаблона и его возможностей</h1>
				<h2>Что такое стартовый шаблон и для чего он нужен?</h2>
				<h3>Сборщики и их режимы работы</h3>
				<p>В шаблоне работают два сборщика GULP и WEBPACK, каждый делает то в чем он хорош. Есть возможность
					работать в режимах разработки и продакшена. Режим разработки выполняет только необходимые для работы
					задачи, а продакшн обеспечивает оптимизацию файлов, конвертацию и прочие необходимые действия. Таким
					образом повышается скорость работы сборщиков. Добавлю что тип работы указанный в package.json равен
					module
				</p>
				<h3>Сборщик GULP
				</h3>
				<p>GULP играет роль вспомогательного сборщика и выполняет следующие задачи:
				</p>
				<ul class="listsp">
					<li>Очищает папку с результатом [все режимы]
					</li>
					<li>Создает файл .gitignore с указанным содержимым [все режимы]
					</li>
					<li>Конвертирует шрифты из .OTF и .TTF в .WOFF и .WOFF2. Записывает данные в файл стилей, в том числе
						формирует font-weight на основе имени файла. [все режимы]
					</li>
					<li>Обрабатывает HTML файлы: добавляет конструкцию <picture> с изображением в .WEBP формате, добавляет
							к
							подключенным JS CSS файлам версию, что позволяет избежать проблем с кэшированием при
							демонстрации
							работы. [режим продакшена]
					</li>
					<li>Обрабатывает CSS файлы: группирует медиа-запросы, добавляет вендорные префиксы для обеспечения
						кроссбраузерности, добавляет подключение .WEBP изображения, оптимизирует и сжимает файл. [режим
						продакшена]
					</li>
					<li>Обрабатывает JS файлы: только передает информацию сборщику WEBPACK [режим продакшена]
					</li>
					<li>Обрабатывает файлы изображений: сжимает и оптимизирует форматы .JPG, .PNG, .SVG. На основе
						.JPG/.PNG
						файлов формируется .WEBP изображение. [режим продакшена]
					</li>
					<li>Создает SVG спрайт [все режимы]
					</li>
					<li>Отправляет файлы с результатом на сервер по FTP [режим продакшена]
					</li>
					<li>Создает ZIP архив с результатом [режим продакшена]
					</li>
				</ul>
				<h3>Сборщик WEBPACK
				</h3>
				<p>WEBPACK играет основную роль сборщика HTML/SCSS/JS файлов и выполняет следующие задачи:
				</p>
				<ul class="listsp">
					<li>Запускает локальный сервер и открывает HTML страницы результата в браузере. При внесении
						изменений,
						сам обновляет страницу. Подключен модуль горячей замены, что увеличивает скорость обновления.
						Также,
						созданные файлы не пишутся на диск, а находятся в памяти. [режим разработчика]
					</li>
					<li>Обрабатывает SCSS файлы: производится преобразование в CSS файлы, переименовываются псевдонимы
						[все
						режимы]
					</li>
					<li>Обрабатывает HTML файлы: производится сборка файлов из подключаемых частей, переименовываются
						псевдонимы [все режимы]
					</li>
					<li>Обрабатывает PUG файлы: производится сборка файлов из подключаемых частей, переименовываются
						псевдонимы, производится преобразование в HTML файлы [все режимы]
					</li>
					<li>Обрабатывает JS файлы: производится грамотная сборка подключенных модулей, таким образом в файл с
						результатом попадает только задействованный в проекте код [все режимы], файл сжимается и
						оптимизируется [режим продакшена]
					</li>
					<li>Копирует файлы из папки files в папку с результатом [все режимы]
					</li>
				</ul>
				<h3>Возможности работы с HTML файлами
				</h3>
				<p>HTML файлы можно собирать из частей благодаря шаблонизатору <a
						href="https://www.npmjs.com/package/file-include-webpack-plugin">FileInclude</a>. То есть мы можем
					вынести
					отдельные части кода, например header и footer, в отдельные файлы и подключать их для всех страниц
					сайта.
					Таким образом, при необходимости внести изменения, нам достаточно редактировать только один
					подключаемый
					файл. FileInclude позволяет передавать переменные со значением в подключаемый файл. Например мы можем
					передать свой заголовок (title) для каждой страницы.
				</p>
				<h3>Шаблонизатор PUG
				</h3>
				<p>Если вам не хватает возможностей FileInclude вы можете использовать шаблонизатор PUG и все его
					возможности. Сборка сама обработает PUG-файлы и преобразует в HTML</p>
				<h3>Использование препроцессора SASS/SCSS, возможности при работе со стилями</h3>
				<p>В шаблоне используется препроцессор SASS в синтаксисе SCSS. Благодаря этому, есть возможность
					порадовать
					вас отличными наработками:
				</p>
				<ul class="listsp">
					<li>Отзывчивое свойство. Миксин, позволяет задать значение для того или иного свойства которое будет
						зависеть от ширины экрана (вьюпорта), что в свою очередь открывает колоссальные возможности для
						адаптивной (отзывчивой) верстки.</li>
					<li>Архитектура подключаемых файлов позволяет использовать только то что нужно для конкретного
						проекта.
					</li>
					<li>Готовые базовые стили для различных JS модулей
					</li>
				</ul>
				<h3>JavaScript возможности, использование модулей</h3>
				<p>Отмечу, что поскольку JS файлы собирает WEBPACK, то у нас появляется возможность использовать
					подключение
					ES6 модулей. Таким образом в результат попадает только используемый функционал. Для добавления той или
					иной возможности, как правило, достаточно раскомментировать строку. Также каждый модуль удобно
					управляется и настраивается с помощью дата атрибутов в HTML/PUG файлах, а сам код подробно
					прокомментирован.
				</p>
				<h4> Вот перечень готового JS функционала «Чертогов Фрилансера» (для подробностей кликайте на название
					модуля):</h4>
				<h3>Общие модули
				</h3>
				<ul class="listsp">
					<li>Табы с возможностью превращения в спойлеры на указанной ширине экрана и прочими настройками
					</li>
					<li>Спойлеры с возможностью включения на указанной ширине экрана и прочими настройками
					</li>
					<li>Модуль «Показать ещё» с возможностью включения на указанной ширине экрана и прочими настройками
					</li>
					<li>Попапы (всплывающие/модальные окна) с переключением фокуса, открытием по хешу и прочим
					</li>
					<li>Галерея (куплена лицензия галереи lightgallery js)</li>
					<li>Слайдер Swiper и дополнительные возможности для интеграции с другими модулями
					</li>
					<li>Подсказки (tippy.js)
					</li>
					<li>Функционал меню «бургер»
					</li>
					<li>Функционал определения поддержки WEBP формата
					</li>
					<li>Вспомогательные, общие для многих модулей, функции блокировки прокрутки с компенсацией скроллбара,
						плавного раскрытия блока, сбор и уникализация медиа-запросов, форматирования чисел, исправление
						ошибки
						полноэкранного блока на мобильных и многое другое.
					</li>
				</ul>
				<h3>Модули работы с формами
				</h3>
				<ul class="listsp">
					<li>Работа с полями ввода, добавление классов, работа с placeholder
					</li>
					<li>Валидация полей, возможность моментальной валидации
					</li>
					<li>Функционал показа пароля
					</li>
					<li>Отправка форм в разных режимах: обычный, AJAX, режим разработчика. Возможность вывода попапа после
						отправки формы.
					</li>
					<li>Модуль кастомизации элемента SELECT с большим набором возможностей</li>
					<li>Модуль работы с масками полей ввода
					</li>
					<li>Модуль ползунка (range) для указания значений поля
					</li>
					<li>Модуль звездного рейтинга
					</li>
					<li>Модуль указания количества кнопками + и —
					</li>
				</ul>

				<h3>Модули работы с прокруткой страницы</h3>
				<ul class="listsp">
					<li>Изменение дизайна скроллбара
					</li>
					<li>Ленивая (отложенная) загрузка данных (lazyload): картинки видео iframe и т.д. при прокрутке
						страницы
					</li>
					<li>Наблюдатель за появлением элементов. Позволяет создавать анимацию и многое другое в момент
						появления/ухода элемента с видимой области экрана (блока)
					</li>
					<li>Навигация по странице (прокрутка к нужному элементу). Также есть возможность добавления класса
						активному пункту навигации</li>
					<li>Работа с шапкой сайта при прокрутке страницы с дополнительными возможностями
					</li>
					<li>«Липкий» блок. Возможность закреплять элемент при прокрутке с гибкими настройками</li>
				</ul>
				<h3>Модули для создания параллакс-эффекта</h3>
				<p>Модуль параллакса мышью. Элементы плавно реагируют на движение мышью
					Система глобального логгинга (Full Logging System или FLS)
				</p>
				<p>Я подумал, почему бы не научить функционал ЧФ общаться (отчитываться) о своей работе пользователю в
					консоли?! Это очень удобно в процессе разработки и имеет обучающий эффект.</p>
			</div>

			<div data-watch data-watch="navigator" id="home2" class="home-menu home2">
				<h1>Установка и запуск шаблона. Подготовка к работе</h1>
				<p>Первым делом следует разархивировать zip-архив в вашу папку проекта. Следите за тем, чтобы сама папка
					и её родительские папки не содержали в названии кириллицу, пробелы, символы # и !
				</p>
				<img src="@img/image1.jpg" alt="" class="img-home">
				<p>Если вы до этого момента не пользовались сборщиками GULP, WEBPACK и пакетным менеджером NPM, следует
					<a href="https://nodejs.org/ru/">скачать и установить Node.js.</a> Качайте версию рекомендованную для
					большинства.
				</p>
				<p>Далее, открываем терминал в этой папке проекта. Терминал может быть встроен или открыт отдельно от
					редактора. Рекомендую использовать терминал <a href="https://git-scm.com/downloads">GIT Bash</a>.
				</p>
				<p>Если вы до этого момента не пользовались сборщиком GULP введите в терминал команду npm <strong>npm i
						gulp-cli -g</strong> это установит GULP в систему глобально.
				</p>
				<p>После завершения установки GULP введите команду <strong>npm i</strong></p>
				<p>В процессе установки в терминале могут возникать сообщение с пометкой WARN на желтом фоне. Эти
					сообщения можно игнорировать. Но, если вы получаете сообщение ERR! красным цветом — это критическая
					ошибка и её нужно исправлять.
				</p>
				<img src="@img/image2.jpg" alt="" class="img-home">
				<p>Часто может возникнуть ошибка зависимостей устанавливаемых пакетов (плагинов), и в NPM выше 7й версии
					это приводит к критической ошибке и остановке инсталляции</p>
				<p>Чтобы решить проблему выполните команду <strong> npm i --legacy-peer-deps</strong>, это запустит
					процесс установки
					игнорируя подобные несовместимости.
				</p>
				<p>Помните — версии NodeJS и Python в вашей системе должны быть свежих версий.</p>
				<p>После успешной установки, у вас появится папка node_modules и файл package-lock.json</p>
				<img src="@img/image3.jpg" alt="" class="img-home">
				<p>Установка завершена
					Подробнее про архитектуру папок и файлов ЧФ мы поговорим в следующей главе, а пока продолжаем
					подготовку к работе</p>
				<h3>Запуск шаблона и режимы работы</h3>
				<h4>Шаблон «Чертоги Фрилансера» может выполнять несколько сценариев:
				</h4>
				<ul class="listsp">
					<li>Режим разработчика. Команда запуска <strong>npm run dev</strong>
					</li>
					<li>Режим продакшена. Команда запуска <strong>npm run build</strong>
					</li>
					<li>Режим продакшена и отправка результата на сервер по FTP. Команда запуска <strong>npm run
							deploy</strong>
					</li>
					<li>Режим продакшена и создание ZIP-архива с результатом. Команда запуска <strong>npm run zip</strong>
					</li>
					<li>Режим продакшена без создания WEBP изображений и действий связанных с этим форматом. Команда
						запуска <strong>npm run devbuild</strong>
					</li>
				</ul>
				<h3>Дополнительные команды:</h3>
				<p>Ручное создание SVG спрайта. Команда запуска <strong>npm run sprite</strong>
					Конвертация шрифтов с принудительной перезаписью файла стилей. Команда запуска <strong>npm run
						fonts</strong>
				</p>
				<h3>Режим разработчика</h3>
				<p>В режиме разработчика выполняются только необходимые для процесса разработки задачи:
				</p>
				<ul class="listsp">
					<li>Конвертация шрифтов и запись в файл стилей
					</li>
					<li>Конвертация SCSS файлов в CSS файлы, переименование псевдонимов</li>
					<li>Сборка HTML файлов, переименование псевдонимов
					</li>
					<li>При использовании PUG, файлы преобразуются в HTML, переименовываются псевдонимы
					</li>
					<li>Собираются JS файлы
					</li>
					<li>Запускается локальный сервер, открывается браузер с индексной страницей.</li>
					<li>Запускается наблюдатель за изменением файлов. При каждом изменении файла браузер обновляет
						страницу (кроме страницы-содержания)
					</li>
					<li>Копируются файлы из указанной папки
					</li>
					<li>HTML CSS JS файлы результата не записываются на диск (папка dist не создается), это увеличивает
						скорость работы.
					</li>
				</ul>
				<h3>Режим продакшена
				</h3>
				<p>В режиме продакшена выполняется финализация проекта, а именно:
				</p>
				<ul class="listsp">
					<li>Конвертация шрифтов и запись в файл стилей</li>
					<li>Конвертация изображений в WEBP формат. Сжатие и оптимизация JPG PNG SVG картинок</li>
					<li>Конвертация SCSS файлов в CSS файлы, переименование псевдонимов, группировка медиа-запросов,
						добавляются вендорные префиксы для обеспечения кроссбраузерности, обрабатывается подключение WEBP
						изображений, производится сжатие и оптимизация конечного файла (также создается несжатая копия)
					</li>
					<li>Сборка HTML файлов, переименование псевдонимов, обрабатывается подключение WEBP изображений
					</li>
					<li>При использовании PUG, файлы преобразуются в HTML, переименовываются псевдонимы, обрабатывается
						подключение WEBP изображений</li>
					<li>Собираются JS файлы, производится сжатие и оптимизация конечного файла. В результат попадает
						только используемый код. Итогом задачи будет создание двух файлов: сжатого app.min.js (подключен к
						HTML) и не сжатого app.js для дальнейшего редактирования другими специалистами.
					</li>
					<li>Копируются файлы из указанной папки
					</li>
					<li>Все файлы с результатом записываются на диск (обычно в папку dist), локальный сервер не
						запускается
					</li>
				</ul>

				<p>Итак, давайте же запустим наш шаблон в режиме разработчика, для этого в терминале выполняем команду
					<strong>npm run dev</strong>
				</p>
				<p>После запуска система выполняет все задачи режима разработчика описанные выше. Результатом работы
					должна стать открытая в браузере страница содержания.
				</p>
				<p>Внимание, страница содержания не обновляется автоматически при её редактировании</p>
				<h3>Возможные ошибки и их решения
				</h3>
				<p>Если браузер не запустился, а в терминале видны ошибки (ERR!) убедитесь что:
				</p>
				<ul class="listsp">
					<li>У вас установлен Node.js и Python последней версии
					</li>
					<li>Терминал открыт с правами администратора</li>
					<li>В названиях папок на всем пути к проекту нет символа # или !
					</li>
					<li>Папки и файлы должны быть названы латиницей без пробелов
					</li>
					<li>Тег img и его содержимое должны быть записаны в одну строку без переносов</li>
					<li>В атрибуте src должен быть указан путь к существующей картинке без пробелов</li>
				</ul>
				<p>При ошибке связанной с node-sass запустите команду <strong>npm rebuild node-sass</strong>
				</p>
				<p>При ошибке связанной с Python запустите команду <strong>npm install -g windows-build-tools</strong>
				</p>
				<h4>При ошибке Error <br>[ERR_ UNSUPPORTED_ESM_ URL_SCHEME]:</h4>
				<p>Качаем версию 14.15.1 (https://nodejs.org/dist/v14.15.1/), в Zip архиве.
					Заходим в папку с установленным NodeJS, распаковываем содержимое архива в папку, с заменой файлов.
					Далее идем сюда «Панель управления» => «Система» => «Дополнительные параметры системы» =>
					«Дополнительно» => «Переменные среды»
					В Системных переменных «Создать» переменную с именем ‘NODE_SKIP_PLATFORM_CHECK’ и присваиваем ей
					значение ‘1’.
				</p>
				<p>Перезапускаем систему, и запускаем шаблон согласно инструкции
				</p>
				<h3>Подготовка редактора к комфортной работе с шаблоном
				</h3>
				<p>Для того чтобы наслаждаться возможностями шаблона ЧФ по полной, нам следует произвести некоторые
					настройки редактора. В качестве примера представлен редактор VS Code</p>
				<h3>Настройка псевдонимов</h3>
				<p>В главе Архитектура шаблона. Файлы и папки вы узнаете что различные части HTML/PUG SCSS файлов
					находятся на разных уровнях вложенности, что создает определенные неудобства при подключении, например
					картинок, в процессе разработки.</p>
				<p>Неудобства мы не любим поэтому настроим, так называемые, псевдонимы (алиасы) путей к папкам. Для этого
					нам нужно установить плагин <a
						href="https://marketplace.visualstudio.com/items?itemName=ionutvmi.path-autocomplete">Path
						Autocomplete.</a> После установки открываем настройки редактора
					(settings.json), для этого жмем F1 в редакторе и в строке поиска пишем Open Settings и жмем на ссылку
					Open Settings (JSON).</p>
				<h4>В этот файл нужно аккуратно вставить следующий код</h4>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-string" style="color: rgb(162, 252, 162);">"path-autocomplete.pathMappings"</span>: {
					<span class="hljs-string" style="color: rgb(162, 252, 162);">"@img"</span>: <span class="hljs-string" style="color: rgb(162, 252, 162);">"${folder}/src/img"</span>, <span class="hljs-regexp" style="color: rgb(198, 180, 240);">//</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">alias</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">for</span> images
					<span class="hljs-string" style="color: rgb(162, 252, 162);">"@scss"</span>: <span class="hljs-string" style="color: rgb(162, 252, 162);">"${folder}/src/scss"</span>, <span class="hljs-regexp" style="color: rgb(198, 180, 240);">//</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">alias</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">for</span> scss
					<span class="hljs-string" style="color: rgb(162, 252, 162);">"@js"</span>: <span class="hljs-string" style="color: rgb(162, 252, 162);">"${folder}/src/js"</span>, <span class="hljs-regexp" style="color: rgb(198, 180, 240);">//</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">alias</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">for</span> js
					}</pre>
				<h4>Очень важно соблюдать синтаксис JSON, обращайте внимания на запятые:</h4>
				<img src="@img/image4.jpg" alt="" class="img-home">
				<p>После этого вы смело можете использовать псевдонимы при подключении файлов, например:
				</p>
				<strong>
					<br>
					&lt;img src=&quot;@img/cover.jpg&quot; alt=&quot;Картинка&quot;&gt;
					</code>
				</strong>
				<p></p>
				<p>Редактор распознает псевдоним и выведет список файлов в указанной папке, а во время сборки система
					сама поменяет псевдоним на нужный путь!</p>
				<h3>Настройка сниппетов
				</h3>
				<p>Сниппеты — это короткие коды которые могут вызывать готовые заготовки кода любого объема. Это колоссально
					повышает скорость разработки.
				</p>
				<p>Конечно же, я использовал эту супер возможность в своих чертогах. То есть, построение, например,
					правильной HTML структуры для того или иного JS модуля я добавил в сниппеты.</p>
				<h4>Чтобы добавить набор сниппетов из шаблона к себе в редактор выполняем следующие действия:
				</h4>
				<ul class=" listsp">
					<li>Открываем файл snnipets.txt из архива ЧФ и копируем все содержимое
					</li>
					<li>В редакторе VS Code переходим в настройки (шестеренка) -> User Snippets ->New Global
						Snippets File пишем название, например fls, и заменяем содержимое на скопированное из
						snnipets.txt
					</li>
					<li>При обновлении шаблона и сниппетов создавать новый файл не нужно, следует открыть
						существующий и обновить содержимое
					</li>
				</ul>
				<p>Отлично, сниппеты ЧФ на борту! В этой документации, а также в коде шаблона вы часто будете
					встречать подсказки с указанием сниппета.
				</p>
				<h3>Дополнительные материалы
				</h3>
				<p>Для лучшего понимания установки Node.JS, GIT Bash, GULP, настройки псевдонимов посмотрите это
					видео:
				</p>
				<a href="https://youtu.be/jU88mLuLWlk">https://youtu.be/jU88mLuLWlk</a>

			</div>

			<div id="home3" class="home-menu">
				<h1>Архитектура шаблона. Файлы и папки</h1>
				<h3>Разархивировать скачанный шаблон, в корне вы обнаружите следующие файлы и папки:
				</h3>
				<ul class="listsp">
					<li>Файл <strong>package.json</strong> — файл содержащий команды запуска сборщиков, информацию об
						установленных
						плагинах и их версиях (можно редактировать при необходимости). А также прочую информацию о об
						авторе и версии шаблона.
					</li>
					<li>Файл <strong>gulpfile.js</strong> — главный файл сборщика GULP. Содержит подключения различных задач
						и сценарии их
						выполнения (можно редактировать при необходимости)
					</li>
					<li>Файл <strong>snnipets.txt</strong> — файл со сниппетами которые используются при работе с шаблоном.
						Как их добавить
						в свой редактор описано тут
					</li>
					<li>Файл <strong>README.txt</strong> — краткая информация по работе с шаблоном
					</li>
					<li>Файл <strong>cover.jpg</strong> — обложка ЧФ
					</li>
					<li>Папка <strong>config</strong> — содержит папки и файлы для настройки работы сборщиков, а также файлы
						с отдельными
						задачами. подробнее..
					</li>
					<li>Папка <strong>src</strong> — содержит исходные файлы и папки проекта. подробнее…
					</li>
				</ul>
				<h3>Содержимое папки config:</h3>
				<ul class="listsp">
					<li>Файл <strong>gulp-settings.js</strong> — содержит настройку путей к файлам и папкам для работы GULP,
						а также
						настройку FTP соединения для выгрузки результата на сервер
					</li>
					<li>Файл <strong>gulp-plugins.js</strong> — вспомогательный файл, содержит подключение и экспорт списка
						общих плагинов
						для задач GULP
					</li>
					<li>Файл <strong>webpack.dev.js</strong> — содержит конфигурацию работы WEBPACK в режиме разработчика
					</li>
					<li>Файл <strong>webpack.prod.js</strong> — содержит конфигурацию работы WEBPACK в режиме продакшн
					</li>
					<li>Папка <strong>gulp-tasks</strong> — содержит файлы отдельных задач GULP
					</li>
				</ul>
				<h3>Содержимое папки src:</h3>
				<ul class="listsp">
					<li>Файл <strong>favicon.ico</strong> — иконка сайта
					</li>
					<li>Файл <strong>index.html</strong> — индексная страница-содержание, она не обновляется автоматически
						при
						редактировании (при желании удалить)
					</li>
					<li>Файл <strong>home.html</strong> — главная страница сайта (при желании переименовать в index.html)
					</li>
					<li>Папка <strong>files (пустая)</strong> — все файлы из этой папки будут скопированы в папку с
						результатом
						(dist/files)
					</li>
					<li>Папка <strong>fonts</strong> (пустая) — используется для подключения локальных и иконочных шрифтов
					</li>
					<li>Папка <strong>svgicons</strong> (пустая) — используется для создания SVG спрайта
					</li>
					<li>Папка <strong>html</strong> — содержит .HTM файлы, которые подключаются в HTML файлы страниц
						(например в
						home.html). Тут можно создавать свои подключаемые файлы
					</li>
					<li>Папка <strong>scss</strong> — содержит файлы и папки стилей сайта
					</li>
					<li>Папка <strong>js</strong> — содержит файлы и папки скриптов сайта
					</li>
					<li>Папка <strong>img</strong> — тут хранятся картинки проекта. Изначально, только кавер-фото шаблона
					</li>
				</ul>
				<h3>Содержимое папки src/html:</h3>
				<h4>Файлы из этой папки предназначены для подключения в HTML-файлы страниц.
				</h4>
				<ul class="listsp">
					<li>Файл <strong>_header.htm</strong> — подготовка для создания шапки сайта. Содержит тег <strong>
							&lt;header&gt;</strong>
						и ограничивающий
						контейнер. Изначально подключен в home.html
					</li>
					<li>Файл <strong>_footer.htm</strong> — подготовка для создания подвала сайта. Содержит тег <strong>
							&lt;footer&gt; </strong> и
						ограничивающий
						контейнер. Изначально подключен в home.html
					</li>
					<li>Файл <strong>_head.htm</strong> — содержит тег <strong>&lt;head&gt;</strong> внутри которого указаны
						метатеги,
						подключена иконка сайта, файл стилей а
						также тег <strong>&lt;title&gt;</strong> с переменной-заголовком. Изначально подключен в home.html
					</li>
					<li>Файл <strong>_js.htm</strong> — предназначен для подключения общих js-файлов. Содержит подключение
						основного
						файла
						js/app.min.js из результата. Изначально подключен в home.html
					</li>
					<li>Файл <strong>_popup.htm</strong> — подготовка для создания попапов. Содержит шаблонный,
						закомментированный
						HTML-код. Изначально подключен в home.html. Смотри работу с попапами. Содержит шаблонный HTML-код.
					</li>
				</ul>
				<h3>Содержимое папки src/scss:</h3>
				<ul class="listsp">
					<li>Файл <strong>style.scss</strong> — основной файл стилей. Содержит различные настройки и подключения
						других
						файлов.
						Подробнее…
					</li>
					<li>Файл <strong>home.scss</strong> — файл стилей главной страницы. Изначально пуст и подключен в
						style.scss
					</li>
					<li>Файл <strong>header.scss</strong> — файл стилей шапки сайта. Содержит закомментированный код кнопки
						меню-бургера.
						Изначально подключен в style.scss
					</li>
					<li>Файл <strong>footer.scss</strong> — файл стилей подвала сайта. Изначально пуст и подключен в
						style.scss
					</li>
					<li>Файл <strong>common.scss</strong> — файл стилей для общих, переиспользуемых блоков конкретного
						проекта.
						Изначально
						пуст и подключен в style.scss
					</li>
					<li>Файл <strong>base.scss</strong> — файл базовых стилей шаблона ЧФ. Содержит полезные SCSS-шаблоны и
						закомментированные подключения файлов с базовыми стилями различных модулей.
					</li>
					<li>Папка <strong>libs</strong> — содержит файлы полных (заводских) стилей различных модулей и плагинов
					</li>
					<li>Папка <strong>fonts</strong> — содержит файл(ы) стилей связанных со шрифтами. Содержит файл
						icons.scss для
						подключения иконочного шрифта. Также, в процессе подключения локальных шрифтов, тут появляется
						файл
						fonts.scss
					</li>
					<li>Папка <strong>base</strong> — содержит вспомогательные файлы стилей ЧФ, а также файлы с базовыми
						стилями
						различных
						моделей. Для удобства, файлы модулей одной группы (например элементы форм) собраны в отдельные
						подпапки. Тут же находится файл с обнуляющими стилями null.scss
					</li>
				</ul>

				</ul>
				<h3>Содержимое папки src/js:</h3>
				<ul class="listsp">
					<li>Файл <strong>app.js </strong> — основной файл скриптов. Служит для подключения необходимого в проекте
						функционала и
						прочих настроек.</li>
					<li>Папка <strong>libs</strong> — содержит файлы готовых дополнений, как правило, не предусмотренных для
						редактирования.</li>
					<li>Папка <strong>files</strong> — содержит файлы различных модулей и прочего функционала.</li>
				</ul>

				<h3>Содержимое папки src/js/files:
				</h3>
				<ul class="listsp">
					<li>Файл <strong>script.js</strong> — предназначен для написания своего кода для проекта. Изначально
						импортирован в
						app.js</li>
					<li>Файл <strong>functions.js</strong> — содержит мелкие модули и различный вспомогательный функционал.
						Изначально
						импортирован в app.js, но модули закомментированы</li>
					<li>Файл <strong>gallery.js</strong> — содержит подключение плагина и стилей галереи. Изначально
						импортирован в app.js,
						закомментирован. При необходимости, в него можно вносить изменения</li>
					<li>Файл <strong>sliders.js</strong> — содержит подключение плагина и стилей слайдера, функционал для
						автоматического
						добавления классов, код для создания конкретных слайдеров. Изначально импортирован в app.js,
						закомментирован.</li>
					<li>Файл <strong>tippy.js</strong> — содержит подключение плагина и стилей плагина подсказок. Изначально
						импортирован в
						app.js, закомментирован.</li>
					<li>Файл <strong>map.js</strong> (в работе) — содержит шаблонный код для реализации функционала карт.
					</li>
					<li>Файл <strong>modules.js</strong> — вспомогательный файл для работы ЧФ.</li>
					<li>Папка <strong>forms</strong> — содержит файлы модулей для работы с формами</li>
					<li>Папка <strong>scroll</strong> — содержит модули для работы с прокруткой сайта</li>
				</ul>
			</div>

			<div id="home4" class="home-menu">
				<h1>Работа со шрифтами. Локальные и иконочные шрифты. Подключение из Google Fonts</h1>
				<p>В стартовом шаблоне «Чертоги Фрилансера» v3.0.0 (далее ЧФ) весь процесс подключения локальных и иконочных
					шрифтов максимально автоматизирован. Исходные файлы шрифтов конвертируются с современные форматы .WOFF и
					.WOFF2, а также производится запись подключения шрифтов в файл стилей, включая значение font-weight на
					основе имени файла.
				</p>
				<h3>Как ЧФ обрабатывает шрифты?
				</h3>
				<p>При запуске шаблона в любом режиме, ЧФ проверит, есть ли файлы шрифтов в форматах .TTF и/или .OTF в папке
					src/fonts.
				</p>
				<h4>Далее происходит три этапа конвертации:
				</h4>
				<ul class="listsp">
					<li>Файлы .OTF (если они есть) конвертируются в .TTF и сохраняются в папке с исходниками src/fonts. </li>
					<li>Файлы .TTF конвертируются в .WOFF и записываются в папку с результатом (dist/fonts)</li>
					<li>Файлы .TTF конвертируются в .WOFF2 и записываются в папку с результатом (dist/fonts)</li>
				</ul>
				<p>После конвертации ЧФ проверит наличие файла стилей scss/fonts/fonts.scss и, <strong>если его
						нет</strong>, запишет в него
					конструкции @font-face для всех файлов, включая значение font-weight основанное на имени файла.</p>
				<p>Если файл scss/fonts/fonts.scss уже существует, данные не перезапишутся. Это сделано для того, что если
					нам придется внести изменения в файл scss/fonts/fonts.scss после работы ЧФ, эти изменения не затерлись.
				</p>
				<p><strong>В каких случаях нам потребуется внести изменения в файл scss/fonts/fonts.scss в ручную?</strong>
					Дело в том, что значение font-weight основывается на имени файла шрифта, то есть если файлы называется
					Roboto-bold, то значение font-weight будет 700. Но если файл будет назван без отделения начертания,
					например RobotoBold, то адекватное определение не удастся и будет записано значение по умолчанию (400). И
					вот в этих случаях нам необходимо отредактировать файл указав адекватные значения.
				</p>
				<p>Если мы хотим перезаписать данные в файле <strong>scss/fonts/fonts.scss</strong>, нам следует его удалить
					и перезапустить систему, или запустить команду <strong>npm run fonts</strong> (система сама удалит файл и
					создаст новый)
				</p>
				<h3>Как подключить локальные файлы шрифтов:</h3>
				<ul class="listsp">
					<li>Скачать или получить от дизайнера/заказчика файлы шрифтов в формате .TTF и/или .OTF и положить их в
						папку src/fonts (если папки нет — создать)
						Раскомментировать подключение файла fonts.scss (строка fonts/fonts) в файле
						<strong>scss/style.scss</strong>
					</li>
					<li>Указать семейство шрифта по умолчанию в переменной $fontFamily в файле
						<strong>scss/style.scss</strong>
					</li>
					<li>Запустить ЧФ в любом режиме
					</li>
				</ul>
				<p>При необходимости, вы можете отредактировать созданный и заполненный файл
					<strong>scss/fonts/fonts.scss</strong>
				</p>
				<p>При необходимости пересоздать данные в файле стилей <strong>scss/fonts/fonts.scss </strong> полностью,
					следует его удалить и перезапустить систему, или запустить команду <strong>npm run fonts</strong>
					(система сама удалит файл и создаст новый)
				</p>
				<h3>Как подключить локальные файлы иконочных шрифтов:
				</h3>
				<ul class="listsp">
					<li>Тем или иным способом создать файл иконочного шрифта в формате .TTF и/или .OTF и положить его в папку
						src/fonts (идет работа над автоматизацией этого процесса)
					</li>
					<li>Отредактировать файл scss/fonts/icons.scss внеся классы для иконок, а также убедится в том что имя
						шрифта (font-family) для SCSS-шаблона %ic {} совпадает с тем что указан в файле scss/fonts/fonts.scss
					</li>
					<li>Раскомментировать подключение файла icons.scss (строка fonts/icons) в файле scss/style.scss
					</li>
					<li>Запустить ЧФ в любом режиме
					</li>
				</ul>

				<h3>Как подключить шрифты из
				</h3>
				<h4>Самый простой способ — это воспользоваться плагином для <a
						href="https://marketplace.visualstudio.com/items?itemName=lior-chamla.google-fonts">VS Code Google
						Fonts:</a>
				</h4>
				<ul class="listsp">
					<li>Нажимаем F1 и ищем плагин Google Fonts
					</li>
					<li>Если хотим подключить шрифт отдельным тегом link в HTML файл, выбираем Google Fonts: insert
						<link>
					</li>
					<li>Если хотим подключить шрифт в файл стилей (обычно это scss/style.scss), выбираем Google Fonts: insert
						CSS @import
					</li>
					<li>Из появившегося списка выбираем нужный шрифт, можно воспользоваться поиском
					</li>
					<li>После вставки строки подключения следует отредактировать строку оставив только нужные начертания
						шрифта
					</li>
					<li>Также следует добавить к строке подключения флаг &display=swap
					</li>
				</ul>
				<h4>Пример подключения шрифта Montserrat:
				</h4>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">@<span class="hljs-keyword" style="color: rgb(252, 194, 140);">import</span> url(https:<span class="hljs-comment" style="color: rgb(136, 136, 136);">//fonts.googleapis.com/css?family=Montserrat:400,500,800&amp;display=swap);</span>
				</pre>
				<p>Шрифты подключенные из Google Fonts не должны попадать в папку с результатом (dist), они подгружаются с
					сервера Google.
				</p>
				<p>Также, стоит отметить, что получить строку для подключения шрифта вы можете и без плагина на сайте <a
						href="https://fonts.google.com/">Google Fonts.</a>
				</p>
			</div>

			<div id="home5" class="home-menu">
				<h1>STYLE.SCSS — настройка адаптивной сетки, шрифтов, подключение дочерних файлов</h1>
				<p>Файл <strong>scss/style.scss</strong> является основным файлом стилей в стартовом шаблоне «Чертоги
					Фрилансера» v3.0.0.
					(далее ЧФ). Обычно, стили проекта тут не пишут, файл выполняет роль материнского файла куда подключаются
					отдельные файлы страниц, модулей и т.д.
				</p>
				<p>Тут же подключаются шрифты и расположены основные переменные для настройки семейства и размера шрифта по
					умолчанию, цветов, адаптивной сетки, корректной работы миксинов и так далее…</p>
				<h3>Настройка семейства, размера и цвета шрифта по умолчанию
				</h3>
				<p>После выполнения действий по подключению шрифтов, необходимо указать значения для следующих переменных:
				</p>
				<p><strong>$fontFamily</strong> — имя семейства шрифта по умолчанию. Указываем имя основного шрифта в
					проекте.</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-variable" style="color: rgb(173, 229, 252);">$fontFamily</span>: <span class="hljs-string" style="color: rgb(162, 252, 162);">"Montserrat"</span>;</pre>
				<p><strong>$fontSize</strong> — размер шрифта по умолчанию. Этой переменной присвоена одна из SCSS-функций
					шаблона, она выполняет перевод пикселей в REM. Соответственно, в эту функцию следует передать значение
					размера шрифта по умолчанию в пикселях (только число без px).
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-meta" style="color: rgb(252, 155, 155);"><span class="hljs-meta-keyword">$fontSize</span>: rem(14);</span></pre>
				<p><strong>$mainColor</strong> — цвет шрифта по умолчанию. Указываем цветовой код.
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-variable" style="color: rgb(173, 229, 252);">$mainColor</span>: <span class="hljs-number" style="color: rgb(211, 99, 99);">#000</span>;</pre>
				<h3>Настройка адаптивной сетки</h3>
				<p>В ЧФ есть возможность настроить ограничивающий контейнер на работу как с отзывчивой адаптивной версткой,
					так и с версткой по брейкпоинтам.
				</p>
				<p>Перед началом работ, настраиваем следующие переменные:
				</p>
				<p><strong>$minWidth</strong> — минимальная ширина вьюпорта (экрана), поддерживаемая проектом. Обычно это
					320px, но, с отмиранием старых устройств, это значение можно менять на любое нужное, указываем только
					число без px:</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-meta" style="color: rgb(252, 155, 155);"><span class="hljs-meta-keyword">$minWidth</span>: 320;</span></pre>
				<p><strong>$maxWidth </strong> — ширина всего макета (полотна), не путать с шириной ограничивающего
					контейнера. Как правило,
					дизайнеры предоставляют макеты шириной 1920 или 1440 пикселей, но это значение может быть любым. Меряем
					макет и указываем только число без px:
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-meta" style="color: rgb(252, 155, 155);"><span class="hljs-meta-keyword">$maxWidth</span>: 1920;</span></pre>
				<p><strong>$maxWidthContainer</strong> — ширина ограничивающего контейнера. Собственно, это ширина контента
					в макете дизайна.
					Меряем макет и указываем только число без px:</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-meta" style="color: rgb(252, 155, 155);"><span class="hljs-meta-keyword">$maxWidthContainer</span>: 1170;</span></pre>
				<p>Если в макете нет ограничения у контента, то есть контент расположен на всю ширину полотна (с отступами),
					то следует указать значение 0 (ноль):
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-meta" style="color: rgb(252, 155, 155);"><span class="hljs-meta-keyword">$maxWidthContainer</span>: 0;</span></pre>
				<p><strong>$containerPadding</strong> — общий отступ (сумма отступов слева и справа) у ограничивающего
					контейнера. Указываем только число без px:
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-meta" style="color: rgb(252, 155, 155);"><span class="hljs-meta-keyword">$containerPadding</span>: 30;</span></pre>
				<p>Если отступов нет, либо вы хотите использовать адаптивное свойство, следует указать 0 (ноль):
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-meta" style="color: rgb(252, 155, 155);"><span class="hljs-meta-keyword">$containerPadding</span>: 0;</span>
					</pre>
				<p><strong>$containerWidth</strong> — ширина срабатывания первого брейкпоинта. Собственно, это сумма ширин
					ограничивающего контейнера и его отступов. Как правило, менять тут ничего не нужно.</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-variable" style="color: rgb(173, 229, 252);">$containerWidth</span>: <span class="hljs-variable" style="color: rgb(173, 229, 252);">$maxWidthContainer</span> + <span class="hljs-variable" style="color: rgb(173, 229, 252);">$containerPadding</span>;</pre>
				<p>
					Вышеуказанные переменные влияют и на функционал отзывчивого свойства, который описан в отдельной статье
				</p>
				<h3>Настройка брейкпоинтов
				</h3>
				<p>Переменным брейкпоинтов присвоена одна из SCSS-функций шаблона <strong>em()</strong>, она выполняют
					перевод пикселей в EM.
				</p>
				<p><strong>$pc</strong> — ПК, ноутбуки, некоторые планшеты в горизонтальном положении. Обычно, тут
					указывается переменная
					<strong>$containerWidth:</strong>
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-variable" style="color: rgb(173, 229, 252);">$pc</span>: em(<span class="hljs-variable" style="color: rgb(173, 229, 252);">$containerWidth</span>);</pre>
				<p><strong>$tablet</strong> — планшеты, некоторые телефоны в горизонтальном положении. Обычно, значение
					равно 991.98px:
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-meta" style="color: rgb(252, 155, 155);"><span class="hljs-meta-keyword">$tablet</span>: em(991.98);</span>
				</pre>
				<p><strong>$mobile</strong> — большие телефоны. Обычно, значение равно 767.98px:</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-meta" style="color: rgb(252, 155, 155);"><span class="hljs-meta-keyword">$mobile</span>: em(767.98);</span></pre>
				<p><strong>$mobileSmall</strong> — маленькие телефоны. Обычно, значение равно 479.98px:</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-meta" style="color: rgb(252, 155, 155);"><span class="hljs-meta-keyword">$mobileSmall</span>: em(479.98);</span>
				</pre>
				<p>Для быстрого вызова медиа запроса с нужным брейкпоинтом можно использовать сниппеты md1, md2, md3, md4.
					Или, для Mobile First, mmd1, mmd2, mmd3, mmd4</p>
				<h3>Настройка типа адаптива (поведения ограничивающего контейнера)
				</h3>
				<p><strong>$responsiveType</strong> — настройка типа адаптива (поведения ограничивающего контейнера):
				</p>
				<ul class="listsp">
					<li>1 — отзывчивость. У контейнера нет брейкпоинтов, он сужается вместе с браузером</li>
					<li>2 — по брейкпоинтам. Контейнер меняет свою ширину по настроенным брейкпоинтам</li>
				</ul>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-meta" style="color: rgb(252, 155, 155);"><span class="hljs-meta-keyword">$responsiveType</span>: 1;</span></pre>
				<p>Ниже, в файле стилей <strong>scss/style.scss</strong> указан селектор ограничивающего контейнера и его
					стили, значения
					которых во многом состоят из настроенных выше переменных.
					Стили ограничивающего контейнера будут применяться к любому элементу в классе которого есть строка
					<strong>«__container»</strong>. Для удобства можно использовать сниппет <strong>cnt</strong>
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;<span class="hljs-keyword" style="color: rgb(252, 194, 140);">div</span> <span class="hljs-built_in" style="color: rgb(255, 255, 170);">class</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"block__container"</span>&gt;
					...
				  &lt;/<span class="hljs-keyword" style="color: rgb(252, 194, 140);">div</span>&gt;</pre>
				<h3>Подключение дополнительных файлов стилей</h3>
				<p>В файл scss/style.scss уже подключены и можно подключать прочие файлы стилей. Порядок подключения имеет
					значение!
				</p>
				<p><strong>@use «sass:math»;</strong> — подключает SASS-модуль математических вычислений. Теперь мы можем
					использовать деление с помощью math.div(число, число).
				</p>
				<p><strong>@import «base/mixins»;</strong> — подключение используемых в ЧФ миксинов. Файл
					scss/base/mixins.scss.
				</p>
				<p><strong>@import «base/null»;</strong> — подключение обнуляющих стилей. Файл scss/base/null.scss.
				</p>
				<p><strong>@import «base»;</strong> — подключение общего файла базовых стилей модулей ЧФ, SASS-шаблонов
					(заготовок) и
					вспомогательных классов. Файл scss/base.scss. Для подключения/отключения конкретных стилей смотри
					scss/base.scss.
				</p>
				<p><strong>@import «common»;</strong> — подключение файла стилей общих элементов конкретного проекта. Файл
					scss/common.scss (изначально пуст).
				</p>
				<p><strong>@import «header»; , @import «footer»;</strong> — подключение стилей отдельных блоков (изначально
					scss/header.scss и scss/footer.scss ). Вы можете дополнять список подключением своих файлов
				</p>
				<p> <strong>@import «home»; </strong> — подключение стилей отдельных страниц (изначально scss/home.scss). Вы
					можете дополнять список подключением своих файлов</p>

				<h3>Селекторы и стили
				</h3>
				<p>Изначально в файле стилей scss/style.scss есть ряд SCSS-селекторов:
				</p>
				<p><strong>body {}</strong> — стили основного тега
					<strong>&lt;body&gt;</strong>
					часть из которых описана в файле обнуления <strong>scss/base/null.scss</strong>. Также добавлена
					подготовка для появления
					у тега <strong>&lt;html&gt;</strong> двух классов:
				</p>
				<ul class="listsp">
					<li><strong>lock</strong> — блокировка скролла. Для этого уже написаны соответствующие CSS-стили
					</li>
					<li><strong>loaded</strong> — сайт загружен. По этому классу мы можем влиять на

						<body> для отображения контента после полной загрузки данных
					</li>
				</ul>
				<p><strong>.wrapper {}</strong> — обвертка всего контента на странице. Для неё написаны стили прижатия
					подвала к низу страницы, важный параметр overflow: hidden; который не даст появиться горизонтальному
					скроллу страницы, а также решение проблемы для слайдеров внутри дочерних flex-элементов.</p>

			</div>

			<div id="home6" class="home-menu">
				<h1>SCSS-Миксин «Отзывчивое (адаптивное) свойство»</h1>
				<p>С помощью SCSS-миксина «Отзывчивое (адаптивное) свойство» можно отзывчиво (в зависимости ширины экрана)
					изменять значение того или иного CSS-свойства от начального значения, на определенной ширине экрана, до
					конечного значения на другой ширине экрана. Можно указывать произвольные промежутки ширин. Также,
					существует несколько режимов поведения миксина вне указанных промежутках.
				</p>
				<p>Миксин представлен в двух реализациях — clamp() и calc(). Сlamp работает быстрее, но если возникают
					проблемы с поддержкой браузерами миксин автоматически переключится на calc().
				</p>
				<p>Принудительно использовать calc() можно изменив код миксина в файле scss/base/mixins.scss
				</p>
				<h3>Использование миксина
				</h3>
				<p>Чтобы работать с миксином нужно в SCSS селекторе вызвать сниппет <strong>av:</strong>
				</p>
				<h4>Базовый режим работы миксина:</h4>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(34, 34, 34); color: rgb(170, 170, 170);">@<span class="hljs-keyword" style="color: rgb(102, 68, 170);">include</span> adaptiveValue(<span class="hljs-string" style="color: rgb(255, 204, 51);">"свойство"</span>, начальное значение, конечное значение);</pre>
				<p>Где:</p>
				<p><strong>свойство</strong> — CSS-свойство, значение которого нужно адаптировать. Можно указать любое
					свойство значение которого указывается в цифрах.</p>
				<p><strong>начальное значение</strong> — стартовое значение свойства в пикселях, пишем число без px. Обычно
					указывается по макету.
				</p>
				<p><strong>конечное значение</strong> — финальное значение свойства в пикселях, пишем число без px.
					Значение, к которому мы хотим прийти на меньших ширинах экрана.
				</p>
				<p>Примеры:
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(34, 34, 34); color: rgb(170, 170, 170);">@<span class="hljs-keyword" style="color: rgb(102, 68, 170);">include</span> adaptiveValue(<span class="hljs-string" style="color: rgb(255, 204, 51);">"font-size"</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">50</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">20</span>);
					@<span class="hljs-keyword" style="color: rgb(102, 68, 170);">include</span> adaptiveValue(<span class="hljs-string" style="color: rgb(255, 204, 51);">"padding-top"</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">80</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">10</span>);</pre>
				<h3>Алгоритм работы миксина
				</h3>
				<p>Миксин работает на основе значений переменных <strong>$minWidth, $maxWidth, $maxWidthContainer,
						$containerPadding
						и $containerWidth</strong> расположенных в блоке «Настройка адаптивной сетки» файла scss/style.scss
				</p>
				<h4>В итоге, по умолчанию, миксин будет работать следующим образом:
				</h4>
				<p>Если <strong>$maxWidthContainer </strong> больше нуля, то значения свойства будут меняться в промежутке
					ширин от
					<strong>$containerWidth</strong> до <strong>$minWidth.</strong> То есть, по всей ширине ограничивающего
					контейнера.
				</p>
				<p>При этом, если ширина экрана больше чем <strong>$containerWidth</strong>, то значение свойства будет
					равно начальному значению. Если ширина экрана меньше чем <strong>$minWidth</strong>, то значение свойства
					будет равно конечному значению.
				</p>
				<p>Если <strong>$maxWidthContainer</strong> равен нулю, то значения свойства будут меняться в промежутке
					ширин от <strong>$maxWidth</strong> до <strong>$minWidth</strong>. То есть, по всей ширине экрана
					(вьюпорта).
				</p>
				<h3>Дополнительные настройки и режимы работы
				</h3>
				<p>Миксин позволяет указать свой промежуток ширины внутри которого будет адаптироваться значение свойства.
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(34, 34, 34); color: rgb(170, 170, 170);">@<span class="hljs-keyword" style="color: rgb(102, 68, 170);">include</span> adaptiveValue(<span class="hljs-string" style="color: rgb(255, 204, 51);">"свойство"</span>, начальное значение, конечное значение, ширина от, ширина до);</pre>
				<ul class="listsp">
					<li><strong>ширина от</strong> — стартовая ширина меньше которой начнется адаптация, пишем число без px.
					</li>
					<li><strong>ширина до</strong> — конечная ширина до которой будет адаптироваться значение свойства, пишем
						число без px.
					</li>
				</ul>
				<h4>Пример:
				</h4>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(34, 34, 34); color: rgb(170, 170, 170);">@<span class="hljs-keyword" style="color: rgb(102, 68, 170);">include</span> adaptiveValue(<span class="hljs-string" style="color: rgb(255, 204, 51);">"font-size"</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">50</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">20</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">800</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">480</span>);</pre>
				<p><strong>режим работы</strong> — может принимать числовые значения 1, 2 или 3:
				</p>
				<ul class="litsp">
					<li><strong>1</strong> — Если ширина экрана больше чем ширина от, то значение свойства будет равно
						начальному значению. Если ширина экрана меньше чем ширина до, то значение свойства будет равно
						конечному значению.
					</li>
					<li><strong>2</strong> — Если ширина экрана больше чем ширина от, то значение свойства будет равно
						начальному значению. Если ширина экрана меньше чем ширина до, то значение свойства будет по умолчанию
						либо наследоваться от предков.</li>
					<li><strong>3</strong> — Если ширина экрана больше чем ширина от, то значение свойства будет по умолчанию
						либо наследоваться от предков. Если ширина экрана меньше чем ширина до, то значение свойства будет
						равно конечному значению.
					</li>
				</ul>
				<h4>Пример:
				</h4>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(34, 34, 34); color: rgb(170, 170, 170);">@<span class="hljs-keyword" style="color: rgb(102, 68, 170);">include</span> adaptiveValue(<span class="hljs-string" style="color: rgb(255, 204, 51);">"font-size"</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">50</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">20</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">800</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">480</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">1</span>);
				</pre>
				<p>Также мы можем использовать несколько вызовов миксина с разными промежутками:</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(34, 34, 34); color: rgb(170, 170, 170);">@<span class="hljs-keyword" style="color: rgb(102, 68, 170);">include</span> adaptiveValue(<span class="hljs-string" style="color: rgb(255, 204, 51);">"font-size"</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">50</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">20</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">800</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">480</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">2</span>);
					@<span class="hljs-keyword" style="color: rgb(102, 68, 170);">include</span> adaptiveValue(<span class="hljs-string" style="color: rgb(255, 204, 51);">"font-size"</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">20</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">10</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">480</span>, <span class="hljs-number" style="color: rgb(0, 204, 102);">320</span>);
					</pre>
				<p>В примере произойдет следующее: значение font-size будет 50px, в промежутке ширин экрана от 800px до
					480px, он будет отзывчиво адаптироваться от 50px до 20px. А в промежутке от 480px до 320px отзывчиво
					адаптироваться от 20px до 10px.
				</p>
				<h3>Расположение
				</h3>
				<p>Миксин <strong>adaptiveValue</strong> находится в файле <strong>scss/base/mixins.scss</strong>
				</p>
			</div>

			<div id="home7" class="home-menu">
				<h1>Модуль меню «бургер»</h1>
				<p>Функционал реагирует на клик по кнопке меню «бургера» (элемент с классом icon-menu). При этом к тегу html
					добавляется класс <strong>menu-open</strong>, а также срабатывает блокировка прокрутки страницы (функция
					<strong>bodyLockToggle()</strong> ). При повторном клике происходят обратные действия.
				</p>
				<h3>Подключение модуля
				</h3>
				<ul class="listsp">
					<li><strong>[HTML]</strong> Вызвать сниппет menu, отредактировать под задачу. Важно чтобы кнопка бургера
						оставалась с
						классом icon-menu
					</li>
					<li><strong>[JS]</strong> В файле <strong>js/app.js</strong> раскомментировать строку
						<strong>flsFunctions.menuInit()</strong>;
					</li>
					<li><strong>[SCSS]</strong> По классу <strong>menu-open</strong> верстаем открытие меню. В файле
						<strong>scss/header.scss</strong> есть закомментированный
						стиль кнопки бургера.
					</li>
				</ul>
				<h3>Расположение и дополнительные данные</h3>
				<p>Функционал находится в <strong>js/files/functions.js</strong>. Название функции
					<strong>menuInit()</strong>, дополнительные функции <strong>menuOpen()</strong> и
					<strong>menuClose()</strong> для открытия/закрытия меню из произвольного кода. Все функции импортируемые.
				</p>
				<h4>Дополнительные материалы</h4>
				<a href="https://youtu.be/zs1r8yafTE8?list=PLM6XATa8CAG6IJvQBkrTTNZmpIcyS2Avk">Перейти</a>

			</div>

			<div id="home8" class="home-menu">
				<h1>Модуль «Popup». Всплывающие (модальные) окна</h1>
				<p>Данный функционал добавляет возможность использовать всплывающие окна. Работа модуля заключается в
					следующем: пользователь нажимает на указанный элемент (по умолчанию это атрибут с указанным селектором
					<strong>data-popup=‘selector‘)</strong>. При этом к тегу <strong>body</strong> добавляется класс
					<strong>popup-show</strong>. Также блокируется прокрутка
					страницы (можно отключить), фокусировка элементов «перелетает» на popup, с запоминанием предыдущего
					сфокусированного элемента на странице. Закрытие popup происходит при клике на кнопку закрытия (по
					умолчанию элемент с атрибутом <strong>data-close</strong> ), по клику на «пустом месте» (не на popup), по
					нажатию кнопки <strong>ESC</strong>.
				</p>
				<h3>Подключение функционала
				</h3>
				<ul class="listsp">
					<li><strong>[HTML]</strong> Подключить файл <strong>_popup.htm</strong>, после оболочки
						<strong>wrapper</strong>, в HTML-файл страницы (уже подключен в home.html)</li>
					<li><strong>[SCSS]</strong> Подключить файл <strong>scss/base/popup.scss</strong> в файл
						<strong>scss/base.scss</strong> — раскомментировать сроку <strong>@import
							‘base/popup’</strong>;
					</li>
					<li><strong>[JS]</strong> Подключить файл <strong>js/libs/popup.js</strong> в файле
						<strong>js/app.js</strong> — раскомментировать строку <strong>import
							‘./libs/popup.js’</strong>
					</li>
				</ul>
				<h3>Использование функционала
				</h3>
				<p>Для того, чтобы вызвать попап, необходимо на странице ввести объект с дата-атрибутом, в котором указан
					селектор (класс или id) всплывающего окна, на которое ссылаемся:
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(34, 34, 34); color: rgb(170, 170, 170);">&lt;a href=<span class="hljs-string" style="color: rgb(255, 204, 51);">"#"</span> data-popup=<span class="hljs-string" style="color: rgb(255, 204, 51);">"#popup"</span> <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(102, 68, 170);">class</span></span>=<span class="hljs-string" style="color: rgb(255, 204, 51);">"link"</span>&gt;Я открываю попап&lt;/a&gt;
				</pre>
				<p>Далее открыть файл <strong>html/_popup.htm</strong> , раскомментировать HTML-код подготовки попапа,
					указать селектор (id или класс) по которому вызывается попап, изменить код под свои нужды.
				</p>
				<h4>В примере попап вызывается по id popup:</h4>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(34, 34, 34); color: rgb(170, 170, 170);">&lt;<span class="hljs-keyword" style="color: rgb(102, 68, 170);">div</span> <span class="hljs-built_in" style="color: rgb(50, 170, 238);">id</span>=<span class="hljs-string" style="color: rgb(255, 204, 51);">"popup"</span> aria-hidden=<span class="hljs-string" style="color: rgb(255, 204, 51);">"true"</span> <span class="hljs-built_in" style="color: rgb(50, 170, 238);">class</span>=<span class="hljs-string" style="color: rgb(255, 204, 51);">"popup"</span>&gt;
					&lt;<span class="hljs-keyword" style="color: rgb(102, 68, 170);">div</span> <span class="hljs-built_in" style="color: rgb(50, 170, 238);">class</span>=<span class="hljs-string" style="color: rgb(255, 204, 51);">"popup__wrapper"</span>&gt;
						&lt;<span class="hljs-keyword" style="color: rgb(102, 68, 170);">div</span> <span class="hljs-built_in" style="color: rgb(50, 170, 238);">class</span>=<span class="hljs-string" style="color: rgb(255, 204, 51);">"popup__content"</span>&gt;
							&lt;button data-close type=<span class="hljs-string" style="color: rgb(255, 204, 51);">"button"</span> <span class="hljs-built_in" style="color: rgb(50, 170, 238);">class</span>=<span class="hljs-string" style="color: rgb(255, 204, 51);">"popup__close"</span>&gt;Закрыть&lt;/button&gt;
							&lt;<span class="hljs-keyword" style="color: rgb(102, 68, 170);">div</span> <span class="hljs-built_in" style="color: rgb(50, 170, 238);">class</span>=<span class="hljs-string" style="color: rgb(255, 204, 51);">"popup__text"</span>&gt;
				
							&lt;/<span class="hljs-keyword" style="color: rgb(102, 68, 170);">div</span>&gt;
						&lt;/<span class="hljs-keyword" style="color: rgb(102, 68, 170);">div</span>&gt;
					&lt;/<span class="hljs-keyword" style="color: rgb(102, 68, 170);">div</span>&gt;
				&lt;/<span class="hljs-keyword" style="color: rgb(102, 68, 170);">div</span>&gt;</pre>
				<h3>Открытие YouTube видео в попапе</h3>
				<p>Для того чтобы открыть видеоролик в попапе, следует добавить к кнопке, которая вызывает попап, атрибут
					<strong>data-popup-youtube</strong>, а в качестве значения указать код ролика. Также следует указать
					атрибут
					<strong>data-popup-youtube-place</strong> для объекта в котором хотим вывести ролик (если атрибут
					<strong>data-popup-youtube-place</strong>
					не будет указан, ролик автоматически появится в объекте с классом <strong>popup__text</strong> ):
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;button <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">type</span></span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"button"</span> data-popup=<span class="hljs-string" style="color: rgb(162, 252, 162);">"#video"</span> data-popup-youtube=<span class="hljs-string" style="color: rgb(162, 252, 162);">"6S5Zw2WuyFE"</span>&gt;Видео&lt;/button&gt;
					&lt;div id=<span class="hljs-string" style="color: rgb(162, 252, 162);">"video"</span> aria-hidden=<span class="hljs-string" style="color: rgb(162, 252, 162);">"true"</span> <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span></span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"popup"</span>&gt;
						&lt;div <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span></span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"popup__wrapper"</span>&gt;
							&lt;div <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span></span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"popup__content"</span>&gt;
								&lt;button data-close <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">type</span></span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"button"</span> <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span></span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"popup__close"</span>&gt;Закрыть&lt;/button&gt;
								&lt;div data-youtube-place <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span></span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"popup__text"</span>&gt;
					
								&lt;/div&gt;
							&lt;/div&gt;
						&lt;/div&gt;
					&lt;/div&gt;</pre>
				<p>Стили попапа можно писать и изменять в файле <strong>scss/base/popup.scss</strong>
				</p>
				<h3>Открытие попапа по хешу
				</h3>
				<p>Для того чтобы открыть попап при открытии страницы, добавляем к адресу хеш с именем селектора попапа</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-symbol" style="color: rgb(211, 99, 99);">https:</span>//template.fls.guru/index.html<span class="hljs-meta" style="color: rgb(252, 155, 155);">#popup</span></pre>
				<h3>Методы и события
				</h3>
				<h4>Методы</h4>
				<p>Работать с попапом из любого места можно импортировать переменную <strong>flsModules</strong>:
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">import</span> { flsModules } from <span class="hljs-string" style="color: rgb(162, 252, 162);">"./modules.js"</span>;
					</pre>
				<p>Далее обратится к классу <strong>popup</strong> и работать с методом, например <strong>open()</strong>
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">flsModules<span class="hljs-selector-class" style="color: rgb(173, 229, 252);">.popup</span><span class="hljs-selector-class" style="color: rgb(173, 229, 252);">.open</span>(<span class="hljs-string" style="color: rgb(162, 252, 162);">'#popup'</span>)
					</pre>
				<p>где <strong>#popup</strong> селектор попапа
				</p>
				<h4>События</h4>
				<p>В классе попапов существуют ряд событий:
				</p>
				<ul class="listsp">
					<li><strong>beforePopupOpen</strong> — сработает перед открытием попапа
					</li>
					<li><strong>afterPopupOpen</strong> — сработает после открытия попапа
					</li>
					<li><strong>beforePopupClose</strong> — сработает перед закрытием попапа
					</li>
					<li><strong>afterPopupClose</strong> — сработает после закрытия попапа
					</li>
				</ul>
				<p>Чтобы работать с событием вешаем прослушку на document</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-built_in" style="color: rgb(255, 255, 170);">document</span>.addEventListener(<span class="hljs-string" style="color: rgb(162, 252, 162);">"afterPopupOpen"</span>, <span class="hljs-function"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">function</span> (<span class="hljs-params">e</span>) </span>{
					<span class="hljs-comment" style="color: rgb(136, 136, 136);">// Попап</span>
					<span class="hljs-keyword" style="color: rgb(252, 194, 140);">const</span> currentPopup = e.detail.popup;
				});
				</pre>
			</div>

			<div id="home9" class="home-menu">
				<h1>Модуль «Динамический адаптив»</h1>
				<p>Во время работы над адаптивом сайта, нам то и дело приходится изменять внешний вид объекта. В некоторых
					случаях нам необходимо изменить порядок элементов, когда при определенном разрешении экрана некоторый
					блок должен находится в совершенно другом месте структуры. Особенно часто это требуется при адаптации
					шапки сайта когда необходимо перенести блок с контактами в меню-бургер.
				</p>
				<p>Функционал динамического адаптива перемещает необходимый блок (на определенном разрешении) в другой блок.
					Перемещение отображается в разметке HTML.
				</p>
				<h3>Подключение функционала
				</h3>
				<p>[JS] В файле <strong>js/app.js</strong> раскомментировать строку import
					<strong>«./libs/dynamic_adapt.js»</strong></p>
				<h3>Использование функционала
				</h3>
				<p>[HTML] В блок который нужно переместить добавляем атрибут <strong>data-da</strong> со значениями атрибута
					указанными ниже:</p>
				<img src="@img/image5.jpg" class="img-home">
				<h3>Расположение и дополнительные данные
				</h3>
				<p>Функционал находится в <strong>js/libs/dynamic_adapt.js</strong>. Название функции
					<strong>DynamicAdapt(type)</strong>.</p>
				<p>У модуля есть ограничения, например, если перекидывать несколько объектов одновременно в один и тот же
					блок, может возникнуть путаница с порядком блоков.</p>
				<h3>Дополнительные материалы</h3>
				<a href="https://youtu.be/QKuMr575vlQ">Перейти</a>

			</div>

			<div id=" home10" class="home-menu">
				<h1>Модуль «Прокрутка к нужному блоку». Плавная навигация по странице.</h1>
				<p>В данном модуле реализован плавный скролл после клика по ссылке (кнопке) до нужного блока на странице.
					Если в адресе страницы будет передан хеш и блок с таким селектором будет найден на странице, прокрутка к
					блоку произойдет автоматически. Также, модуль позволяет построить навигацию по странице с добавлением
					класса текущему пункту навигации (пункту меню) при скролле к определенному блоку.
				</p>
				<h3>Подключение функционала
				</h3>
				<p><strong>[JS]</strong> В файле <strong>js/app.js </strong> раскомментировать строку
					<strong>flsScroll.pageNavigation()</strong>;
				</p>
				<h3>Использование функционала</h3>
				<p><strong>[HTML]</strong> К элементам навигации (пунктам меню), либо к произвольному объекту, добавляем
					HTML-атрибут <strong>data-goto </strong> а в качестве значения указываем CSS селектор блока до которого
					нужно прокрутить:
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;a href=<span class="hljs-string" style="color: rgb(162, 252, 162);">"#"</span> data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">goto</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">".имя класса блока"</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"link"</span>&gt;Пункт навигации&lt;/a&gt;</pre>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;a href=<span class="hljs-string" style="color: rgb(162, 252, 162);">"#"</span> data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">goto</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"#id блока"</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"link"</span>&gt;Пункт навигации&lt;/a&gt;</pre>
				<p>Если нужно чтобы скролл учитывал шапку (не докручивал на высоту шапки, используется при фиксированных
					шапках) нужно добавить к объекту навигации атрибут <strong>data-goto-header:</strong></p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;a href=<span class="hljs-string" style="color: rgb(162, 252, 162);">"#"</span> data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">goto</span>-header data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">goto</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">".имя класса блока"</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"link"</span>&gt;Пункт навигации&lt;/a&gt;</pre>
				<p>Если нужно чтобы скролл не докручивал до блока на указанную высоту необходимо добавить к объекту
					навигации атрибут <strong>data-goto-top</strong> а в качестве значения указать число — необходимую
					высоту:
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;a href=<span class="hljs-string" style="color: rgb(162, 252, 162);">"#"</span> data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">goto</span>-top=<span class="hljs-string" style="color: rgb(162, 252, 162);">"30"</span> data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">goto</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"#id блока"</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"link"</span>&gt;Пункт навигации&lt;/a&gt;</pre>
				<p>data-goto-top можно совмещать с <strong>data-goto-header</strong>, тогда значение data-goto-top добавится
					к высоте шапки.
				</p>
				<h3>Добавление класса к текущему пункту навигации
				</h3>
				<h4>Для включения функционала добавления класса подключаем модуль наблюдатель:
				</h4>
				<ul class="listsp">
					<li><strong>[JS]</strong> В файле <strong>js/app.js</strong> раскомментировать строку <strong>import
							‘./libs/watcher.js’</strong>
					</li>
					<li><strong>[HTML]</strong> Для блоков к которым прокручивается страница добавляем атрибут
						<strong>data-watch</strong> со значением navigator:
					</li>
				</ul>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;a href=<span class="hljs-string" style="color: rgb(162, 252, 162);">"#"</span> data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">goto</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">".some-section"</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"link"</span>&gt;Пункт навигации&lt;/a&gt;</pre>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;section data-watch=<span class="hljs-string" style="color: rgb(162, 252, 162);">"navigator"</span> <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span></span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"some-section"</span>&gt;<span class="xml"><span class="hljs-tag" style="color: rgb(98, 200, 243);">&lt;/<span class="hljs-name" style="font-weight: 700;">section</span>&gt;</span></span></pre>
				<p>После этого, при прокрутке к облоку (объекту) навигации, к соответствующему пункту навигации будет
					добавлен класс <strong>_navigator-active</strong>
				</p>
				<h3>Прокрутка к нужному блоку по хешу (при открытии страницы)
				</h3>
				<p>Для того чтобы прокрутить страницу к нужному блоке при открытии страницы необходимо добавить к адресу хеш
					содержащий <strong>имя класса нужного блока</strong>.
				</p>
				<p>Пример адресной строки и нужного блока:
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-symbol" style="color: rgb(211, 99, 99);">https:</span>//template.fls.guru/index.html<span class="hljs-meta" style="color: rgb(252, 155, 155);">#some-section</span></pre>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;section <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span></span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"some-section"</span>&gt; <span class="xml"><span class="hljs-tag" style="color: rgb(98, 200, 243);">&lt;/<span class="hljs-name" style="font-weight: 700;">section</span>&gt;</span></span></pre>
				<h3>Добавление функционала, плавная прокрутка на iOS
				</h3>
				<p>По умолчанию, прокрутка выполняется методом scrollTo() с параметром behavior: «smooth» без применения
					дополнительных плагинов. Но это ограничивает функционал этого модуля — нельзя указать скорость прокрутки,
					а также могут возникнуть проблемы в некоторых версия браузеров на iOS. Для решения всех проблем, можно
					подключить дополнительный плагин SmoothScroll, сделать это можно в файле js/files/scroll/gotoblock.js
					раскомментировав строку import SmoothScroll from ‘smooth-scroll’; дальнейшее переключение прокрутки на
					плагин произойдет автоматически.
				</p>
				<p>При работе с плагином появляется возможность указать скорость прокрутки, для этого элементу навигации
					нужно добавить атрибут data-goto-speed и указать число означающее количество миллисекунд за которые
					совершится прокрутка (1000 = 1 секунда), по умолчанию 500.
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;a href=<span class="hljs-string" style="color: rgb(162, 252, 162);">"#"</span> data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">goto</span>-speed=<span class="hljs-string" style="color: rgb(162, 252, 162);">"1000"</span> data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">goto</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">".some-section"</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"link"</span>&gt;Пункт навигации&lt;/a&gt;</pre>
				<h3>Расположение и дополнительные данные
				</h3>
				<p>Функционал находится в <strong>js/files/scroll/scroll.js</strong>. Название функции
					<strong>pageNavigation()</strong>. Вспомогательный
					модуль прокрутки <strong>gotoblock</strong> находится в <strong>js/files/scroll/gotoblock.js</strong>.
					Модуль наблюдатель находится в файле
					<strong>js/libs/watcher.js</strong>.
				</p>
				<p>Если в момент клика на пункт навигации было открыто меню «бургер», то оно закроется автоматически.
				</p>
			</div>

			<div id="home11" class="home-menu">
				<h1>Модуль добавления классов к шапке при прокрутке страницы</h1>
				<p>Функционал позволяет добавлять класс к тегу header с классом header при прокрутке страницы вниз, а также
					другой класс при остановке прокрутки. Таким образом, можно добиться эффекта когда при самом скролле вниз
					шапка не видна, но стоит остановить скролл, как шапка плавно появляется вверху страницы (становится
					фиксированной). При обратной прокрутке вверх шапка так же остается видна.
				</p>
				<p>Класс <strong>_header-scroll</strong> добавляется к шапке при скролле вниз (через указанное кол-во
					пикселей).
				</p>
				<p>При остановке скролла добавляется класс <strong>_header-show</strong>.
				</p>
				<h3>Подключение функционала
				</h3>
				<p><strong>[JS]</strong> В файле <strong>js/app.js</strong> раскомментировать строку
					<strong>flsScroll.headerScroll()</strong>;
				</p>
				<h3>Использование функционала
				</h3>
				<p><strong>[HTML]</strong> К тегу <strong>header</strong>, добавляем HTML-атрибут
					<strong>data-scroll</strong>, в значении атрибута указываем через какое кол-во прокрученных вниз пикселей
					нам необходимо добавить класс к header (обычно по высоте шапки, по умолчанию 1px).</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;header data-scroll=<span class="hljs-string" style="color: rgb(162, 252, 162);">"120"</span> <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span></span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"header"</span>&gt; <span class="xml"><span class="hljs-tag" style="color: rgb(98, 200, 243);">&lt;/<span class="hljs-name" style="font-weight: 700;">header</span>&gt;</span></span></pre>
				<p>Теперь как только пользователь прокрутит вниз указанные выше 120px к header добавится технический класс
					<strong>_header-scroll</strong>. Этот класс будет присутствовать до тех пор, пока пользователь не
					вернется на самый вверх
					(не доходя 120px).
				</p>
				<h4>Результат работы:</h4>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;header data-scroll=<span class="hljs-string" style="color: rgb(162, 252, 162);">"120"</span> <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span></span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"header _header-scroll"</span>&gt; <span class="xml"><span class="hljs-tag" style="color: rgb(98, 200, 243);">&lt;/<span class="hljs-name" style="font-weight: 700;">header</span>&gt;</span></span></pre>
				<p><strong>[HTML]</strong> Далее к тегу header, добавляем еще один HTML-атрибут
					<strong>data-scroll-show</strong>. Как только пользователь
					остановит прокрутку к тегу header, через определенное время, добавится еще один технический класс
					<strong>_header-show</strong>. Этот класс исчезает только в моменте прокрутке вниз. При прокрутке вверх
					класс не исчезает.
				</p>
				<h4>Результат работы:</h4>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;<span class="hljs-built_in" style="color: rgb(255, 255, 170);">header</span> data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">scroll</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"120"</span> data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">scroll</span>-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">show</span> class=<span class="hljs-string" style="color: rgb(162, 252, 162);">"header _header-scroll _header-show"</span>&gt; &lt;/<span class="hljs-built_in" style="color: rgb(255, 255, 170);">header</span>&gt;</pre>
				<p>Время задержки добавления класса <strong>_header-show</strong> можно менять. Для это следует указать
					значение атрибута
					<strong>data-scroll-show</strong> в миллисекундах (по умолчанию 500)</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;<span class="hljs-built_in" style="color: rgb(255, 255, 170);">header</span> data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">scroll</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"120"</span> data-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">scroll</span>-<span class="hljs-keyword" style="color: rgb(252, 194, 140);">show</span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"1000"</span> class=<span class="hljs-string" style="color: rgb(162, 252, 162);">"header _header-scroll _header-show"</span>&gt; &lt;/<span class="hljs-built_in" style="color: rgb(255, 255, 170);">header</span>&gt;</pre>
				<p><strong>[SCSS]</strong> Теперь осталось отредактировать свойства этих подключенных классов в scss.
					Например:</p>
				<img src="@img/image6.jpg" class="img-home">
				<h3>Расположение и дополнительные данные
				</h3>
				<p>Функционал находится в <strong>js/files/scroll/scroll.js</strong>. Название функции
					<strong>headerScroll()</strong>
				</p>


			</div>

			<div id=" home12" class="home-menu">
				<h1>Модуль «Наблюдатель» за появлением элементов при прокрутке страницы (скролле)</h1>
				<p>Модуль «Наблюдатель» можно использовать для решения самых разных задач: анимация элементов при скролле,
					подсветка активного пункта меню (используется в модуле «Прокрутка к нужному блоку») и многих других.
				</p>
				<p>Суть работы наблюдателя заключается в добавлении класса <strong>_watcher-view</strong> элементу в момент
					его появлении в
					вьюпорте (экране) при скролле а также при открытии страницы. И, соответственно, убран при уходе объекта
					из вьюпорта.
				</p>
				<h3>Подключение модуля
				</h3>
				<p><strong>[HTML]</strong> Для объекта, за которым нужно установить наблюдение, следует добавить атрибут
					<strong>data-watch</strong>
				</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;div data-watch <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span></span>=<span class="hljs-string" style="color: rgb(162, 252, 162);">"block"</span>&gt; <span class="xml"><span class="hljs-tag" style="color: rgb(98, 200, 243);">&lt;/<span class="hljs-name" style="font-weight: 700;">div</span>&gt;</span></span></pre>
				<p><strong>[JS]</strong> В файле <strong>js/app.js</strong> раскомментировать строку import
					<strong>‘./libs/watcher.js’</strong></p>
				<h3>Дополнительные настройки:
				</h3>
				<ul class="listsp">
					<li><strong>data-watch-root=’селектор’</strong> — селектор родителя внутри которого наблюдать за
						объектом. По умолчанию
						&lt;body&gt;
					</li>
					<li><strong>data-watch-margin=’значение’</strong> — отступ от родителя. Указываем значение в PX или в %
					</li>
					<li><strong>data-watch-threshold=’значение’</strong> — процент показа объекта для срабатывания. Где 1 =
						100% показ
						объекта. Указываем только целые или десятичные числа, по умолчанию 0. Может содержать массив значений
						через запятую.
					</li>
					<li><strong>data-watch-once</strong> — наблюдать только один раз. То есть класс к объекту добавится
						только один раз и не
						будет убран при уходе объекта из вьюпорта.
					</li>
				</ul>
				<p>Пример — класс добавится только один раз, при появлении объекта на 50% его высоты:</p>
				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);">&lt;div <span class="hljs-keyword" style="color: rgb(252, 194, 140);">data</span>-watch-threshold=<span class="hljs-string" style="color: rgb(162, 252, 162);">"0.5"</span> <span class="hljs-keyword" style="color: rgb(252, 194, 140);">data</span>-watch-once <span class="hljs-keyword" style="color: rgb(252, 194, 140);">data</span>-watch <span class="hljs-class"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">class</span>="<span class="hljs-title" style="color: rgb(255, 255, 170);">block</span>"&gt; &lt;<span class="hljs-type" style="color: rgb(255, 255, 170);">/div</span>&gt;</span></pre>
				<h3>События</h3>
				<p>После каждом срабатывании наблюдателя, возникает событие <strong>watcherCallback</strong>, его можно
					отловить в любой
					части кода:
				</p>

				<pre class="hljs"
					style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(51, 51, 51); color: rgb(255, 255, 255);"><span class="hljs-built_in" style="color: rgb(255, 255, 170);">document</span>.addEventListener(<span class="hljs-string" style="color: rgb(162, 252, 162);">"watcherCallback"</span>, <span class="hljs-function"><span class="hljs-keyword" style="color: rgb(252, 194, 140);">function</span> (<span class="hljs-params">e</span>) </span>{
					<span class="hljs-comment" style="color: rgb(136, 136, 136);">// Полная информация от наблюдателя</span>
					<span class="hljs-keyword" style="color: rgb(252, 194, 140);">const</span> entry = e.detail.entry;
					<span class="hljs-comment" style="color: rgb(136, 136, 136);">// Наблюдаемый объект</span>
					<span class="hljs-keyword" style="color: rgb(252, 194, 140);">const</span> targetElement = entry.target;
				});</pre>

				<h3>Расположение и дополнительные данные
				</h3>
				<p>Функционал находится в файле <strong>js/libs/watcher.js</strong>. Название класса
					<strong>ScrollWatcher</strong>. Модуль построен на основе <a
						href="https://developer.mozilla.org/ru/docs/Web/API/Intersection_Observer_API">Intersection Observer
						API.</a>
				</p>
				<p>Модуль снабжен системой <strong>FLS</strong> и будет сообщать о своих действиях в консоль браузера</p>



			</div>

			<div id="home13" class="home-menu">
				<h1>Модуль «Показать ещё»
				</h1>
			</div>

			<div id="home14" class="home-menu">
				<h1>Модуль «Табы»
				</h1>
			</div>

			<div id="home15" class="home-menu">
				<h1>Модуль «Спойлеры»
				</h1>
			</div>

			<div id="home16" class="home-menu">
				<h1>Модуль «Ленивая подгрузка» (Lazy Loading)</h1>
			</div>

			<div id="home17" class="home-menu">
				<h1>Модуль слайдера «Swiper»
				</h1>
			</div>

			<div id="home18" class="home-menu">
				<h1>Работа с формами и элементами форм</h1>
			</div>

			<div id="home19" class="home-menu">
				<h1>Модуль кастомизации элемента SELECT
				</h1>
			</div>

			<div id="home20" class="home-menu">
				<h1>Модуль «Галерея»</h1>
			</div>

		</section>

		@@include('html/_footer.htm',{})
	</div>
	@@include('html/_popup.htm',{})
	@@include('html/_js.htm',{})
</body>

</html>